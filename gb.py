# -*- coding: utf-8 -*-
"""GB

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11qF1OhtkCYfEExjPW4t2V2gEOdLNVUhD
"""

# app.py

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta

st.set_page_config(
    page_title="Global Superstore: Order Priority Explorer",
    layout="wide",
    initial_sidebar_state="expanded",
)

@st.cache_data
def load_data(path):
    df = pd.read_excel(path, engine="openpyxl")
    # Create lead-time as (Ship Date - Order Date) in days
    df['Lead Time'] = (df['Ship Date'] - df['Order Date']).dt.days
    return df

# ---------------------------------------------------------
# 1) Load dataset
# ---------------------------------------------------------
df = load_data("Global Superstore.xlsx")

# ---------------------------------------------------------
# 2) Sidebar: Interactive Filters
# ---------------------------------------------------------
st.sidebar.header("🔎 Filter Your Dataset")

# 2a) Date range filter (Order Date)
min_date = df['Order Date'].min()
max_date = df['Order Date'].max()
start_date, end_date = st.sidebar.date_input(
    label="Order Date Range",
    value=(min_date, max_date),
    min_value=min_date,
    max_value=max_date,
)

# 2b) Region filter
regions = df['Region'].unique().tolist()
selected_regions = st.sidebar.multiselect(
    label="Select Region(s)",
    options=regions,
    default=regions,
)

# 2c) Category filter
categories = df['Category'].unique().tolist()
selected_categories = st.sidebar.multiselect(
    label="Select Category(ies)",
    options=categories,
    default=categories,
)

# 2d) Ship Mode filter
ship_modes = df['Ship Mode'].unique().tolist()
selected_shipmodes = st.sidebar.multiselect(
    label="Select Ship Mode(s)",
    options=ship_modes,
    default=ship_modes,
)

# Apply all filters to df
mask = (
    (df['Order Date'] >= pd.to_datetime(start_date)) &
    (df['Order Date'] <= pd.to_datetime(end_date)) &
    (df['Region'].isin(selected_regions)) &
    (df['Category'].isin(selected_categories)) &
    (df['Ship Mode'].isin(selected_shipmodes))
)
filtered = df[mask].copy()

st.sidebar.markdown(f"**📊 Records after filtering:** {filtered.shape[0]:,}")

# ---------------------------------------------------------
# 3) Main Content
# ---------------------------------------------------------
st.title("Global Superstore – Order Priority Dashboard")
st.markdown(
    """
    This dashboard shows how various features (Sales, Profit, Lead Time, Region, Category, Ship Mode, etc.)
    relate to **Order Priority**. Use the sidebar controls to filter the data, then inspect the charts below.

    A neural‐network model trying to predict `Order Priority` will benefit from:
    1. Understanding how `Lead Time` varies by priority.
    2. Checking whether `Sales` or `Profit` distributions differ across priorities.
    3. Spotting region‐ or category‐specific priority skews.
    4. Examining correlations among numerical predictors.
    """
)

# ---------------------------------------------------------
# 3a) Summary metrics
# ---------------------------------------------------------
col1, col2, col3, col4 = st.columns(4)
with col1:
    st.metric("Total Orders", f"{filtered.shape[0]:,}")
with col2:
    st.metric("Distinct Customers", f"{filtered['Customer ID'].nunique():,}")
with col3:
    st.metric("Distinct Products", f"{filtered['Product ID'].nunique():,}")
with col4:
    st.metric("Avg. Lead Time (days)", f"{filtered['Lead Time'].mean():.1f}")

st.markdown("---")

# ---------------------------------------------------------
# 3b) Distribution of Order Priority (bar chart)
# ---------------------------------------------------------
st.subheader("📈 Distribution of Order Priority")
fig1, ax1 = plt.subplots(figsize=(6, 4))
priority_order = ['Low', 'Medium', 'High', 'Critical']
counts = filtered['Order Priority'].value_counts().reindex(priority_order)
counts.plot(kind="bar", ax=ax1, color="#ffa500")
ax1.set_xlabel("Order Priority")
ax1.set_ylabel("Number of Orders")
ax1.set_title("How Many Orders by Priority")
for p in ax1.patches:
    ax1.annotate(
        f"{int(p.get_height()):,}",
        (p.get_x() + p.get_width() / 2, p.get_height()),
        ha="center",
        va="bottom",
        fontsize=9,
    )
st.pyplot(fig1)

# ---------------------------------------------------------
# 3c) Box plots: Sales, Profit, Lead Time by Order Priority
# ---------------------------------------------------------
st.subheader("📊 Box Plots of Numeric Features by Order Priority")
tab1, tab2, tab3 = st.tabs(["Sales", "Profit", "Lead Time"])

with tab1:
    fig2, ax2 = plt.subplots(figsize=(6, 4))
    filtered.boxplot(
        column="Sales",
        by="Order Priority",
        showcaps=True,
        boxprops=dict(color="#ff8c00"),
        whiskerprops=dict(color="#ff8c00"),
        medianprops=dict(color="red"),
        patch_artist=True,
        showfliers=False,
        ax=ax2,
    )
    ax2.set_title("Sales by Order Priority")
    ax2.set_xlabel("Order Priority")
    ax2.set_ylabel("Sales")
    plt.suptitle("")  # Remove the automatic "Boxplot grouped by ..." title
    st.pyplot(fig2)

with tab2:
    fig3, ax3 = plt.subplots(figsize=(6, 4))
    filtered.boxplot(
        column="Profit",
        by="Order Priority",
        showcaps=True,
        boxprops=dict(color="#ff8c00"),
        whiskerprops=dict(color="#ff8c00"),
        medianprops=dict(color="red"),
        patch_artist=True,
        showfliers=False,
        ax=ax3,
    )
    ax3.set_title("Profit by Order Priority")
    ax3.set_xlabel("Order Priority")
    ax3.set_ylabel("Profit")
    plt.suptitle("")
    st.pyplot(fig3)

with tab3:
    fig4, ax4 = plt.subplots(figsize=(6, 4))
    filtered.boxplot(
        column="Lead Time",
        by="Order Priority",
        showcaps=True,
        boxprops=dict(color="#ff8c00"),
        whiskerprops=dict(color="#ff8c00"),
        medianprops=dict(color="red"),
        patch_artist=True,
        showfliers=False,
        ax=ax4,
    )
    ax4.set_title("Lead Time (days) by Order Priority")
    ax4.set_xlabel("Order Priority")
    ax4.set_ylabel("Lead Time")
    plt.suptitle("")
    st.pyplot(fig4)

st.markdown("---")

# ---------------------------------------------------------
# 3d) Stacked‐bar: Order Priority by Region
# ---------------------------------------------------------
st.subheader("🌐 How Order Priority is Distributed Across Regions")
region_priority = (
    filtered.groupby(["Region", "Order Priority"])
    .size()
    .unstack(fill_value=0)
    .reindex(columns=priority_order)
)

fig5, ax5 = plt.subplots(figsize=(10, 4))
region_priority.plot(
    kind="bar",
    stacked=True,
    ax=ax5,
    color=["#ffa500", "#ff8c53", "#e03131", "#d63384"],
)
ax5.set_xlabel("Region")
ax5.set_ylabel("Number of Orders")
ax5.set_title("Stacked Bar: Order Priority per Region")
ax5.legend(title="Priority", bbox_to_anchor=(1.02, 1), loc="upper left")
plt.xticks(rotation=45, ha="right")
st.pyplot(fig5)

st.markdown("---")

# ---------------------------------------------------------
# 3e) Correlation Heatmap (numeric features)
# ---------------------------------------------------------
st.subheader("🔍 Correlation Heatmap of Numeric Features")
numeric_cols = ["Sales", "Quantity", "Discount", "Profit", "Lead Time"]
corr_matrix = filtered[numeric_cols].corr()

fig6, ax6 = plt.subplots(figsize=(6, 5))
sns.heatmap(
    corr_matrix,
    annot=True,
    fmt=".2f",
    cmap="coolwarm",
    linewidths=0.5,
    cbar_kws={"shrink": 0.8},
    ax=ax6,
)
ax6.set_title("Correlation Matrix")
st.pyplot(fig6)

# ---------------------------------------------------------
# 3f) Dataframe preview (optional)
# ---------------------------------------------------------
with st.expander("📋 Show Filtered Dataframe"):
    st.dataframe(filtered.head(200))

# ---------------------------------------------------------
# 4) Tips for Next Steps (neural‐network modeling)
# ---------------------------------------------------------
st.markdown("---")
st.subheader("💡 Tips: Feature Engineering & Modeling Considerations")
st.markdown(
    """
    1. **Lead Time**:
       - We can see from the box plot that “Low” priority orders tend to have longer lead times,
         whereas “Critical” tend to ship same‐day or next day.
       - **Next step**: Consider binning `Lead Time` (e.g., 0 days, 1–2 days, 3–5 days, >5 days)
         or feeding it as a numerical feature.

    2. **Sales & Profit**:
       - The distributions are skewed. High‐priority/critical orders often have larger sales or
         higher profits but also more negative outliers.
       - **Next step**: You may want to take log(Sales) and/or log(Profit + offset) to reduce skewness,
         or create a feature like `Profit Margin` = Profit / Sales.

    3. **Categorical Variables**:
       - **Region, Ship Mode, Category, Sub‐Category, Segment** all look important.
       - **Next step**: One‐hot encode Region, Ship Mode, Category, Sub‐Category, and Segment.
         You can also try ordinal encoding if you believe there’s a rank.

    4. **Temporal Features**:
       - `Order Date` can be split into Month, Quarter, Day‐of‐Week. There may be seasonality
         in “High” or “Critical” orders around holiday seasons, end‐of‐quarter, etc.
       - **Next step**: Extract `Order Month`, `Order Weekday`, `Order Quarter` and feed those.

    5. **Customer & Product IDs**:
       - Directly feeding raw IDs usually doesn’t help. Instead, aggregate by `Customer` (e.g.,
         average order value, frequency) or by `Product/Sub‐Category` (e.g., average sales,
         average lead time). Then join back as features.
       - **Next step**: Create small aggregated tables:
         - Customer‐level features: total orders, average sales, proportion of high‐priority
         - Product‐level features: average profit, average lead time.

    6. **Balancing the Target**:
       - “Low” orders are far fewer than “Medium.” If you train directly, the model may be biased
         toward predicting “Medium.”
       - **Next step**: Consider stratified sampling or class‐weighting in your loss function.

    7. **Correlation Insights**:
       - Notice how `Sales` and `Profit` correlate (~0.31). High Sales often means high Profit.
       - If two features are extremely correlated, you might drop one or run dimensionality
         reduction (e.g., PCA) before feeding into the NN.

    8. **Final Neural‐Net Input**:
       - **Numerical**: Scaled versions of Sales, Profit, Quantity, Discount, Lead Time, aggregated
         customer/product features.
       - **Categorical**: One‐hot encodings for Region, Ship Mode, Category, Sub‐Category, Segment,
         plus engineered temporal features (Month, Weekday, Quarter).
       - **Tip**: Standardize or MinMax‐scale all numerical features before passing to the NN.
       - **Tip**: Use an embedding layer for high‐cardinality features (e.g., Customer ID, Product ID)
         if you have enough data.

    Once you’ve done this exploratory step, you can iterate on feature sets and hyperparameters.
    The patterns you see above (lead time shorter for critical orders, profit skew differences,
    regional differences) should guide your model architecture and loss weighting.
    """
)